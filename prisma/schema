// src/vacinacao/vacinacao.service.ts

import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service'; // Ajuste o caminho se necessário
import { RegistrarVacinacaoDto } from './dto/registrar-vacinacao.dto';
import { StatusCiclo } from '@prisma/client';

@Injectable()
export class VacinacaoService {
  constructor(private readonly prisma: PrismaService) {}

  async registrar(dto: RegistrarVacinacaoDto) {
    // Usamos uma transação para garantir a consistência dos dados.
    // Se qualquer uma das operações falhar, tudo é desfeito (rollback).
    return this.prisma.$transaction(async (tx) => {
      // 1. Verifica se o felino e a vacina existem
      const felino = await tx.felinos.findUnique({ where: { id: dto.felinoId } });
      if (!felino) {
        throw new NotFoundException(`Felino com ID ${dto.felinoId} não encontrado.`);
      }
      const vacina = await tx.vacinas.findUnique({ where: { id: dto.vacinaId } });
      if (!vacina) {
        throw new NotFoundException(`Vacina com ID ${dto.vacinaId} não encontrada.`);
      }

      // 2. Encontra ou Cria o Protocolo Vacinal
      // O Prisma se encarrega de encontrar um protocolo com base na chave única (felinoId_vacinaId)
      // ou criar um novo se não existir.
      let protocolo = await tx.protocoloVacinal.upsert({
        where: { felinoId_vacinaId: { felinoId: dto.felinoId, vacinaId: dto.vacinaId } },
        update: {}, // Não atualiza nada se já existir, retorna o que existe
        create: {
          felinoId: dto.felinoId,
          vacinaId: dto.vacinaId,
          dosesNecessarias: dto.dosesNecessarias,
          intervaloEntreDosesEmDias: dto.intervaloEntreDosesEmDias,
          requerReforcoAnual: dto.requerReforcoAnual,
          status: StatusCiclo.PENDENTE, // Começa como pendente
        },
      });

      // 3. Cria o registro da aplicação da vacina (a dose)
      await tx.aplicacaoVacina.create({
        data: {
          laboratorio: dto.laboratorio,
          lote: dto.lote,
          medVet: dto.medVet,
          // A data de aplicação e valor pago podem ser adicionados aqui se vierem do DTO
          protocoloVacinalId: protocolo.id,
        },
      });

      // 4. Atualiza o Status do Protocolo
      // Contamos quantas doses já foram aplicadas para este protocolo
      const dosesAplicadas = await tx.aplicacaoVacina.count({
        where: { protocoloVacinalId: protocolo.id },
      });

      let novoStatus = StatusCiclo.EM_ANDAMENTO;
      let proximaData: Date | null = new Date();

      if (dosesAplicadas >= protocolo.dosesNecessarias) {
        novoStatus = StatusCiclo.COMPLETO;
        proximaData = null; // Ciclo completo, não há próxima data
      } else {
        // Calcula a data da próxima dose
        proximaData.setDate(proximaData.getDate() + protocolo.intervaloEntreDosesEmDias);
      }

      // Atualiza o protocolo com o novo status e a próxima data
      const protocoloAtualizado = await tx.protocoloVacinal.update({
        where: { id: protocolo.id },
        data: {
          status: novoStatus,
          dataProximaVacina: proximaData,
        },
        include: {
          aplicacoes: true, // Retorna o protocolo com as aplicações para confirmação
        },
      });

      return protocoloAtualizado;
    });
  }
}